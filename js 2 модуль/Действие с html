// М НАУЧИЛИСЬ ПОЛУЧАТЬ ЕЛЕМЕНТ СО СТРАНИЦ А СЕГОДНЯ НАУИЧЕМСЯ ИЗМЕНЯТЬ ИХ И ТД.

// 1) М МОЖЕМ ОБРАТИТЬСЯ НЕ К ЕЛЕМЕНТУ А УЖЕ К САМОМУ ОБЪЕКТУ ТОЕСТЬ 
// console.dir(box) // здесь мы уже в консоли получаем наш елемент в качестве объекта где записаны все возможные действия с ним
// в том числе и внутр  этого объекта есть еще один объект который содержит css свойства где мы можем посмотреть
// какие свойстава м можем поменять, но все свойства которые здесь записан это инлайн свойства но как
// поработать со свойствами которе у нас получились из css  стилей поговорим попозже,
// а сейчас порботаем с инлайн

// 1) сначала мы прописуем  ну или обращаемся к нашому елементу дальше к его объекту стайл и дальше прописуем
// то свойство которое хотим изменить

box.style.alignItems = 'center'

// важно заметить что в css свойствах мы свойства пишем через чорточку -, но в джава скрипте как мы помним
// так нельзя и поэтому заместь черточки мы просто пишем слово но с большой буквы, 
// но важно помнить что когда мы прописуем в js css свойстава то важно помнить что их нужно писать  также как в css
// в ковычках даже когда хотим указать размер и тд.

box.style.width = '500px'

// и важно помнить что инлайн стили они будут перебевать css  стили и сделано это дляьтоого что бы мы могли раюотатать
// с js 

box.style.color = 'red'

// если у нас несколько таких объектов с таким классом и мы помним что такие объект содержаться в псевдомасивах
// то при изменение стилей будет ошибка потому что как мы знаем псевдолкассы немощи и они ничего не знают про свойстава
// по этому всегда нужно ставить индекс того елемента с которым хотим рабоаттьь 

box[0].style.color = 'blue'

// но что если мы хотим изменить сразу несокльк свойств, не удобно прописовать каждую строчку с новым свойством неудобно
// для этого существует такой способ 

box.style.cssText = 'background-color: blue; width: 500px';
// таким способ м можем задать сразу несоклько свойств 
// также удобно тем что мы моем и подставить какуюто переменную 


box.style.cssText = `background-color: blue; width: ${num}px`;
// это очень полезно если м определеныый параметры расчитуем  динамически, например ширина какого-то
// модального окна зависит от того с какого устройства зшел пользователь 

// теперь если нам нужно над сразу несколькоми елементами произвести одни и тежи действия 
// то здесь мы можем использовать самый простой цыкл или for of или forEach - который существует толкьо когда мы используем
// метод queryElectorAll(), давайте посмотрим несоклько вариантов 

//1) прстой цыкл и каждый раз когда мы будем работать с массивами то лучше назначать переменной ноль
// потому что все елементы идут по порядку и начинаються с 0 инлекса

for (let i = 0; i < hearts.length; i++){
    hearts[i].style.backgroundColor = 'blue'
}

// мы создаем цыкл с переменно 0 почему уже сказано выше, дальше говорим что будет выполняться до тих пор пока
// у нас остануться елементы в нутри этого псевжомасива, дальше мы ствами наш елемент и указуем индекс, 
// туда пишем переенную которая будет постепенно увеличиваться на 1 раз  значит и ндекс будет расти и таким образов
// мы будем обращаться к каждому елементу, ну а дальше делаем то что обычно, какие действие будут проиходит
// с каждый елементом, но увы ме не будем часто исопльзовать цыклы так как у нас етсь более продвинутые

// 2) способ for.Eeach работает все также само

hearts.forEach(item =>{
    item.style.backgroundColor = 'blue'
})

// теперь мы знаем как работать сразу со всеми елементами, и следущим нашим шагоб будет изучение основных методов
// для работы  с елеменатми на страницы, очень часто части сайтов создаютьсч при помощи скрипта на тких принцепах
// построен реакт там все елементы созданы при помощи скрипта и мы с вами должны уметь создавать  такие новые елементы
// на литу  для этого используеться метод  ВОТ ПРИМЕР

const div = document.createElement('div');

// внутри скобок метода createElement мы дожны поместить насвание нашего тега и все лемент создан и он существует
// толкьо внутри джава скрипта и на страницы не как не появиться 
// такм же образом мы можем создавать  и тестовые узлы это елементы без оболочки тега 

const text = document.createTextNode('Тут был я ') // и такйо текст у нас появитсья на страницы но такой метод
// использоватьс ябудет редко 

// чаще всего когда мы будем работать с елементом на срнациы ме не будем использовть инлайн стли как делали это выше
// а будем использвать css стили  и это работает так, но существойет простое свойтсов которе называеться
// classname где мы можем указать через пробел какието классы  и добавить их к елементу  но не рекомендую исопльзовтаь
// его потому что он устаревший и есть боллее лучше способ котрый называеться classlist где через точку 
// мы можем писать действие с нашим классом это удаление переключение проверка на содержание  или даже проверка на /
// приминение количвество классов 

div.classList.add('black')

//мы пишем наш блок дальше свойство classlist и после  указать действие которые будет воспроизводиться 
// тоесть это уже метод на совйстов classslist и самый простой это add() - тоесть мы можем добавить
// определенный класс, все наш елемент создан  он сейчас лежит в нашей коробке которая есть только внутри
// джава скрипта к html никакого значение не имеет и на страницы его коненчо же нет 
// здесь мы  вами воспользуемся дерево дом, дело в том что людлой елемент можно вставить в конец  вставить после определеного 
// елемента, удалить или заминить но только по отношению ку другому елементу  нам ведь нудно чтотко сказать
// где разместить этот елемент, сейчаст мы разберем с вами современый метод со страницой но в устарелый браузера
// они рабоать не будут  
// пазберем самый просто вариант, нам нудно добавить див самый конец бади  что бы он наконецто там повялиься 
// на страницы 

document. body.append(div)
// по простмоу это значит что мы образаемься к самому главному тегу это телу нашей страницы
// как к родителбю и в самый конец доболвяем наш див 
// но мы можем его вставить не только в конец и не тольков в бади но также и любого другого блока 
// если мы хотим что бы наш див попал в конец его нового будущего родителя то нужно братиться к 
// родителюб и добавить наш див 
// еще если я использлаать буду переменную только один раз то мне ее не надо помещать в другую 
// можно сразу написать 
document.querySelector('.block').append(div) // а так нам не нужно будет создавтаь переменную выше и указвывать
// ей querySelector() и обращаться к елементу
// образаемься при помощи querySelector к классу блок нашего родителя и добовляем в него новый елемент div при помощи
// append()
// ну а если нам нужно исопльзовтаь несколько раз то можно просто создать перееменную и использвоать ее

const wrapper = document.getquerySelector('.block')

// wrapper.append(div) // вот так 

// есть и обратный метод котрый вставляет в начало 

wrapper.prepend(div); // ставит в верху

// ну и также в джс есть метод перед и псоле before and after которые ставят елемент перед и после

hearts[0].before(div);// перве что мы указуем елемент перед который будет стоять другой елемент после 
// before и в скобках елемент который будет стоять ну и аналогичйны это after
hearts[0].after(div); 
// помимо этого мы можем елементы удалять со страницы  remove

cercles[0].remove(); // сначала указуем какой елемент хотим удалить псоле метод remove 

// ну и метод который пригодиться в нашей жизни это  replace with - для того что бы один елемент заменить другим 

hearts[0].replaceWith(cecrles[0]); // сначала мы указуем какой елемент хотим заменить 
// дальше метод replaceWith который может нам это сделать и в скобках указуем на какой елемент заменим



// теперь разберем УСТАРЕВШИЕ конструкции которые редко используються но их надо знать 

// первое это appendchild - то что appaend но только старый формой 

wrapper.appendchild(div) // поставит наш елемент в конец другого 

weapper.instertBefore(div, hearts[0]) // раньше при работы со странице таких елемнтов как before after prepend 
// небыло и использовали этот метод, в скобках первый елемент тот который мы хотим поставить, а дальше перед каким елементом
// мы поставим

// еще небыло такого елемента как   remove(); и использовали 

wrapper.removeChild(hearts[1])

// также не существоало hearts[0].replaceWith(cecrles[0]); а был такой

wrapper.replaceChild(circle[0], hearts[0])

// ВСЕ ОТЛИЧНО МАНИПУЛИРОВАТЬ ЕЛЕМЕНТАМИ МЫ НАУЧИЛИСЬ И УЗНАЛИ СТАРЫЕ СПОСОБЫ КАК ЭТО СДЕЛАТЬ
// ТЕПЕРЬ ВРЕМЯ ПРИШЛО А КАК ЖЕ ДОБОВЛЯТЬ КАКОЙТО ТЕКСТ ИЛИ  HTML КОД ПРЯМО УЖЕ В ЕЛЕМЕНТЫ

// НАПРИМЕР У НАС УЖЕ ЕСТЬ  ЕЛЕМЕНТ С ЕГО ОБОЛОЧКОЙ 
div.classList.add('black') // ТЕПЕРЬ ПРИСТУПИМ У ЕГО РЕДАКТИРОВАНИЮ
// ДОПУСТИМ ВПИШЕМ В НЕГО ПРОСТОЙ ТЕКСТ

div.innerHTML = "<h1>Hello World</h1>" // мы внутри нашего блока помищяем заголовок с текстом и этот текст будет
// внутри нашего блока, обязательно всегда указем в строчном типе данных
// с помощью такой структуры innerHTML перед нами разкрываеться много возможностей  мы можем при помощи таких строк
// формировать структур нашего сайта и сразуже ее туда помищать 
// ЕСТЬ КОНЕЧНО ЖЕ И ВТОРОЙ ВАРИАНТ

div.textContent = 'hello world' // но такая структура как мы видем по нозванию не будет иметь таких же особеностей 
// как innerHTML, по скольку по названию мы видем что он работаетт тобько с текстом и если мы попытаемсья
// помести html структуру например заголовок первго типа h1 то он у нас запишиться в виде строки, по этому такой метод
// раюотает только с текстом и сделано в цели безопастности
// по скольку если вдруг мы попытаемься использовать  innerHTML к примеру задать вопрос
// или вывести модальное окно и тд. то пользователь можт случайно или нарошно вести какието данные или скрипт
// и сайт просто полетит или будут нехорошие последствия
// ПОЭТОМУ КОГДА МЫ ЧЕТКО ЗНАЕМ ЧТО ХОТИМ ПОЛУЧИТЬ ОТ ПОЛЬЗОВАТЕЛЯ  ТОЛЬКО ТЕКСТ  МЫ ИСПОЛЬЗУЕМ textContent
// А КОГДА ПРЕДПОЛОГАЕТЬСЯ РАБОТА С HTML СТРУКТУРОЙ ТОГДА МЫ С ВАМИ ИСПОЛЬЗУЕМ innerHTML

//А ТЕПЕРЬ КАК НАМ ВСТАВИТЬ КУСОЧЕК HTML КОДА  ПЕРЕД ИЛИ ПОСЛЕ ОПРЕДЕЛЕННЫХ ТЕГОВ И ДЛЯ ЭТОГО У НАС ЕСТЬ ТАКОЙ МЕТОД
div.insertAdjacentHTML('beforebegin', '<h1>Hello</h1>' )// первое это куда вставялем а второе что вставляем

//beforbegin - занимаеться тем что вставляет  этот штмл код перед елементом
//afterbegin - вставляет в начало нашего елемента
//beforend - всатвляет в конец
// afterend - вставляет после елемента

//  И ТАК ПОД КОНЕЦ ЕЩЕ ОДНА НЕОЧЕВИДНАЯ ВОЗМОЖНОТЬ JS ПО ПОЛУЧЕНИЮ ЕЛЕМЕНТОВ 
//  И ТАК КАЖДЫЙ РАЗ КОГДА МЫ ПОЛУЧАЛИ ЕЛЕМЕНТЫ МЫ ОБРОЩАИСЬ ЧЕРЕЗ DOCUMENT
// ДОПУСТИМ У НАС В ВЕРСТЕ ЕСТЬ wrapper внутри которого есть 3 елемента hearts
// у нас также есть получение этого елемента
wrapper = documnt.querySelector('.wrapper')
// и если у меня уже есть такой родитель  то я могу сказать что прямо внутри вот этого блока который я только то 
// получил мне необходимо  получить определный  елемент
// например здесь мы получали hearts
// hearts = document.querySelectorAll('.hearts')
// но теперь заместь document  я могу заменить на wrapper
hearts = wrapper.querySelectorAll('.hearts') // это значит что в эту переменную пойдут только те елементы 
// которые подойдут по данному селектору  и находяться только в нутри вот этого елемента wrapper
// таким образом мы четко говорим что нам нужно


 





