'use strict'

const box = document.getElementById('id')

console.log(box)

//const boxe = document.getElementsByTagName('button')

// для того чтобы взаемодействоать с елементами на страницы нам нужно создать переменнную которая даст нам 
// понять с каким объектом мы хотим работать и обязательно писать document. и после точки писать метод
// метод getElementById() позволяет нам обратиться к елементу по его айди который мы указали в html
// в скобка пишем уже айди, дальше у нас команда здесь работать не будет потому что document не будет найден
// ведь мы обращаемься к страницы и для этого нам надо открыть консоль на страницы и там мыы увидем результат
// мы увидем класс нашего элемента и его id и сможем в дальнейшем с ним взаемодействовать, 
// также мы можем обращаться по тегу для этого нужно прописать после точки getElementsByTagName но увы тегов много и по
// этому мы просто пулчим псевдомасив из всех тегов с таким же названием которе мы укажем, по этому лучше использовать id
// ну если мы обращаемься по тегу мы знаем что если у нас несколько тегов то у нас в консоли выдаст
// псевдомассивы из все тех тегов и что бы обратиться к какомуто одному из них есть 2 способа
// 1) это указать индекст елемента с которым хотим работать пример вот
const boxe = document.getElementsByTagName('button')[1]
// здесь мы указуем что будем обращаться к елементу  по его индексу

// 2) способ это указать индекс уже в выводе консоля

console.log(boxe[1])

// НО ДОПУСТИМ ТЕГ У НАС ОДИН ТО ЕСЛИ МЫ ЕГО ВЫВЕДЕМ ТО ВСЕРОГНО ПОЛУЧИМ В КОНСОЛЬ ПСЕВДОМАСИВ КОТОРЫЙ СОДЕРЖИТ ТОЛЬКО 1 ЕЛЕМЕНТ
// ВАЖНАЯ ДЕТАЛЬ ТО ЧТО  В БУДУЩЕМ ЕСЛИ МЫ ЗАХОТИМ ПОМЕНЯТЬ ЦВЕТ ЭТОМУ ЕЛЕМЕНТУ ТО УВЫ НЕ СМОЖЕМ, ПОТОМУ ЧТО НАШ МАССИВ 
// ВООБЩЕ НИЧЕГО НЕ ЗНАЕТ О СТРАНИЦЫ И МЫ НЕ СМОЖЕМ ОБРАТИТЬСЯ К НЕМУ И ПОМЕНЯТЬ ЧТО ТО И ЧТО БЫ ТАКОГО НЕБЫЛО
// В CONSOLE.LOG() НУЖНО ВСЕГДА СТАВИТЬ ИНДЕКС ЭТОГО ЕЛЕМЕНТА В ДАННОМ СЛУЧАЕ ЕСЛИ ОН 1 ТО УКАЗАТЬ ИНДЕКС 0

// ПОМИМО ТЕГОВ И АЙДИ МЫ МОЖЕМ ПОЛЬЗОВАТЬСЯ КЛАССАМИ ПРИМЕР
const circles = document.getElementsByClassName('circle') // ЗДЕСЬ МЫ УБРАЩАЕМСЯ К КЛАССУ НА СТРАНИЦЫ
// НУ И ЭТОТ МЕТОД РАБОТАЕТ ТАКЖЕ КАК И ТЕГ
console.log(circles)// В КОНСОЛЬ ВЫВЕДЕТ ПСЕВДОМАССИВ

// И НЕБОЛЬШОЙ ЛАЙФХАК ПОЧЕМУ ТАК ПОЛУЧАЕТЬСЯ, ЕСЛИ МЫ ВНИМАТЕЛЬНО РАСМОТРИМ НАШШ ЕЛЕМЕНТ ТО МЫ ЗАМЕТЕМ ЧТО В НЕМ
// УКАЗАНО Elements В МНОЖЕСТВЕНОМ ЧИСЛЕ, А С АЙДИ НЕТ Element ПО ЭТОМУ ТАК И ПРОИСХОДИТ ЧТО С АЙДИ У НАС
// ПОЛУЧАЕТЬСЯ ТОЛЬКО 1 ЕЛЕМЕНТ 

// НУ И БОЛЕЕ СОВРЕМЕННЫЕ МЕТОДЫ И ОНИ БОЛЕЕ ФУНКЦИОНАЛЬНЫЕ 
const hearts = document.querySelectorAll('.heart');

// ЭТОТ МЕТОД УСТРОИН ТАК ЧТО ВО ВНУТРЬ МЫ ПОМЕЩАЕМ CSS СЕЛЕКТОР ПРИЧЕМ ЛЮБОЙ КОТОРЫЙ НАМ НУжЕН БУДЕТ, ЭТО МОЖЕТ
// БЫТЬ УНИКАЛЬНЫЙ ИНДИФИКАТОР ИЛИ ПРОСТО КЛАСС ВЛОЖЕНОСТЬ КЛАССОВ И ТД.И ЗА СЧЕТ ЭТОГО ОН БУДЕТ НАМНОГО ПРИЯТНЕЙ
// И К ТОМУ ЖЕ ЕСТЬ БОЛЬШОЙ ПЛЮС ЭТОГО ЕЛЕМЕНТА, КОГДА МЫ РАЗБИРАЛИ ПСЕВДОМАССИВЫ  ЧТО ОНИ ПО ФАКТУ НИЧЕГО НЕ УМЕЮТ
// НО ДЛЯ querySelectorAll(); ЭТО ИСКЛЮЧЕНИЕ ПОТОМУ ЧТО У НЕГО ПОЯВЛЯЕТЬСЯ ОДИН МЕТОД КОТОРЫЙ НАЗЫВАЕТЬСЯ 
// forEach, И ДА КОГДА МЫ В СКОБКАХ УКАЗУЕМ СЕЛЕКТОР ТО ОБЯЗАТЕЛЬНО ДЕЛАЕМ ЭТО ЧЕРЕЗ ТОЧКУ
console.log(hearts) //  ТАК КАК СЕЛЕКТОРОВ У НАС МОЖЕТ БЫТЬ МНОГО МЫ С ВАМИ ПОЛУЧАЕМ HTMLcolection
// НО КАК Я И СКАЗАЛ ПРИЙМУЩЕСТВО  forEach ПОЗВОЛЯЕТ НАМ СДЕЛАТЬ ЭТО

hearts.forEach(item =>{
    console.log(item)
});

// ТАКИМ ОБРАЗОМ У НАС ВЫВЕДЕТЬСЯ КАЖДЫЙ ЕЛЕМЕНТ В КОНСОЛЬ И МЫ СМОЖЕМ С НИМ ВЗАЕМОДЕСТВОАТЬ 
// ТАКЖЕ ЕСТЬ ПОХОЖЫЙ ЕЛЕМЕНТ 
const oneHearts = document.querySelector('.hearts');
console.log(oneHearts) // ТАКОЙ ЕЛЕМЕНТ ПОЗВОЛЯЕТ НАМ ПОЛУЧИТЬ ТОЛЬКО ОДИН ЕЛЕМЕНТ СО СТРАНИЦЫ
// ПОЛУЧАЕТЬСЯ ТОТ ЕЛЕМЕНТ КОТОРЫЙ ПОПАЛ ПЕРВЫЙ ПОД СОЧИТАНИЕ СТРАНИЦКЕ ТОТ И БУДЕТ ВЫВЕДЕН


// И ТАК НЕБОЛЬШОЙ ИТОГ

// 1) У НАС ЕСТЬ МЕТОДЫ КОТОРЫЕ РАБОТАЮТ НА ОБЪЕКТЫ МОДЕЛЕЙ ДОКУмЕНТА СОООТВЕТСВЕНО В КОДЕ ОН ЗАПИСУЕТЬСЯ КАК
// document И РАБОТАЕТ ТОЛЬКО ВНУТРИ БРАУЗЕРА, У НЕГО ЕСТЬ ТОЛЬКО 2 МЕТОДА ЧТО БЫ ПОЛУЧИТЬ
// ОДИН ЕЛЕМЕНТ БРАУЗЕРА getElementById('id') КОТОРЫЙ ПОЛУЧЕАЕТ УНИКАЛЬНЫЙ ЕЛЕМЕНТ ПО УНИКАЛЬНОМУ ИНДИФИКАТОРУ И ЭТО
// querySelector('.hearts'); КОТОРЫЙ ПРОСТО ПОЛУЧАЕТ ПЕРВЫЙ ЕЛЕМЕНТ КОТОРЫЫЙ ЕМУ ПОПАЛЬСЯ ПОД УКАЗАНЫЙ СЕЛЕКТОР
// С НИМИ МОЖЕ СРАЗУЖЕ И ВЗАЕМОДЕЙСТВОВАТЬ, 

// 2) ПО МИМО ЭТОГО  М ТАКЖЕ МОЖЕМ ПОЛУЧАТЬ HTMLcolection ПСЕВДОМАССИВЫ  ДЛЯ ЭТОГО У НАС ЕСТЬ МЕТОДЫ КАК
// const boxe = document.getElementsByTagName('button')[1]
// const circles = document.getElementsByClassName('circle')
// const hearts = document.querySelectorAll('.heart');
// ЗДЕСЬ  ДЛЯ ТОГО ЧТО Б ИСПОЛЬЗОВАТЬ ЕЛЕМЕНТЫ НА СТРАНИЦЕ НАМ НЕОБХОДИМО УЖЕ ИСПОЛЬЗОВАТЬ  КАКИЕ-ТО ИНДЕКС,

// 3) НУ И ПОСЛЕДНЯЯ ВАЖНАЯ ИНОРМАЦИЯ ЭТО ТО ЧТО М ПЕРЕДАЕМ  ВО ВНУТРЬ ТЕХ КРУГЛХ СКОБКАХ, ЕСЛИ М ИЩЕМ КЛАСС
// ПРИ ПОМОЩИ getElementsByClassName('circle') ТО ОН УЖЕ ЗНАЕТ ЧТО М РАБОТАЕМ С КЛАССОМ  И ВНУТРИ СКОБОК ПЕРЕД
// КЛАССОМ ТОЧКУ НЕ НУЖНО СТАИВТЬ, НО ЕСЛИ ЖЕ М РАБОТАЕМ С КАКИМТО CSS СЕЛЕКТОРОМ querySelectorAll('.heart');
// ТО ЗДЕСЬ УЖЕ ТОЧКА НУЖНА ПОТОМУ ЧТО М ИЩЕМ ИМЕННО ПО КЛАССУ, ТОЖЕ САМОЕ РАБОТАЕТ С АЙДИ И ТАМ НАМ НЕ НУЖНО
// СТАВИТЬ РЕШОТКУ ПОТОМУ ЧТО В САМОМ МЕТОДЕ УЖЕ ПРЕДПОЛОГАЕТЬСЯ ЧТО М РАБОТАЕМ С АЙДИ 
// А ЗДЕСЬ querySelectorAll('.heart'); НАМ РЕШЕТКА НУЖНА ЕСЛИ М БУДЕМ ИСКАТЬ УНИКАЛЬНЙ ИНДИИКАТОР 

