// мы уже знаем что внутри функции может создаваться другая функция и тут возникает вопрос
// а что если это функцию вызвать внутри себя же, это и называеться Рекурсия
// зазберем сначала классический пример  это функция возведенная в степень
// выглядит следущим образом
//pow(2, 2) // первый аргумент это база, а второй это возведение в ступень, в данном случае выйдет 4 по скольку 2 во
// 2 степени 4
// так же само еще пример
//pow(2, 3)
//pow(2, 4) // и тд. и чтобы написать такую функцию есть 2 подхода

// 1) подход по написанию
function pow(x, n) {
    let result = 1;

    for (let i = 0; i < n; i++){
        result *= x;
    }
    
    return result;
}

// pow(2, 1)
// разбираем функцию, сначала когда у нас приходит аргумент (x), (x) это 2, вместо (n) у нас приходит 1
// тоесть цыкл будет длиться только 1 раз по скольку переменная (i) не должна быть больше аргумента (n)
// внутри цыкла у нас выполняеться умножение нашей переменной на (x) тоесть 2, а дальше сохроняем  наш результат
// тоесть переменую result, дальше если подставить уже степень 2 в (n) то у нас уже цыкл будет выполняться 2 раза
// и выходит что result сначала умножиться на x тоесть 1 * 2 будет = 2, дальше эта двойка сохраниться в result и дальше
// цыкл будет еще раз сработает и уже result со значение 2 * на x тоесть 2 и результат будет 4
// вот таким способом можно подвести в степень

// но тут вопрос, если у нас функция по возвидению в степень, вот здесь мы только что так и делали то почему бы
// вместо цыкла нам не запускать её же эту саму функцию,
// скажем что у нас будет та же функция pow(), внутри убераем все, оставляем те же аргументы и теперь мы можем начать
// прописывать условия, и помним если у нам нужно возвести степень в еденицу то нам просто нужно вернуть
// то число которое мы возведем потому что при умножение на одни мы получаем то же число, по этому тут можно написать
// условие, тоесть если наш (n) - тоесть степень будет ровна 1 то просто вернем наш x, но если вдруг это не 1 то
// 2) подход по написанию 
function pow(x, n) {
    if (n === 1){ // #2
        return x 
    } else {
        return x * pow(x, n -1) // #1 вот это и есть рекурсия
    }
}

// pow(2, 2)
// но теперь давайте разберемся что тут происходит, первый случай понятно, второй случай else, если нам приходят две
// двойки, тоесть pow(2, 2) - нужно возвести x в степень n, то здесь (#1) вместо x становиться 2 а дальше 2 умножаеться
// на pow(x, n - 1) тоесть вот здесь у нас будет результат возведения двойки на n - 1 в данном случае будет 2 * 2
// потому что pow(x, n - 1), здесь подставялем  (x) - 2, (n - 1) это 2 - 1 , будет 1 и этот результат умножаем на x
// 2 * 1 = 2 после полученого значени ввыполняем return x * (наш результат) тоесть 2 * 2, сложно но надо запомнить
// что return x * pow(x, n - 1) - pow(здесь будет резульат возведения нашего x в степень n - 1)
// и когда у нас  будет много степеней то у нас будет вложеность функций тоесть одна функция будет внутри себя вызывать
// другую другую и другую до тех пор пока мы не дойдем до какой-то базовой вещи  базовой функции которая нам вернет
// значение, вот это и есть рекурсия когда функция сама себя внутри запускает для каких-то действий
// конечно это может быть не только вычесления каких-то цифр или прочее мы еще расмотрим несколько вариантов дальше
// но самое главное что мы делаем тоже самое что и цыклом только при помощи того что функция запускает сама себя 

// впереди расмотрим еще несколько терменов которые могут пригодиться, начнем мы с базы рекурсии
// это случий который приводит сразу к завершению функций тоесть например как здесь #2 когда у нас n передаеться
// как например 1 то вот этот случий у нас приводит сразу к завершению и возращению x это  база так что в данном
// случае 1 это база рекурсии на ней она как бы точно завершиться,
// дальше есть один шаг рекурсии  это запуск вложеной функции но уже с другим значением в данном случае
// pow(x, n - 1) мы можем видеть что каждый раз (n) уменьшаеться на 1 это и есть шаг рекурсии и каждый раз у нас
// какой-то елемент упрощаеться, третий термин это глубена рекурсии - это общее количество  вложенных вызовов вместе с
// самым первым
// так что у нас есть БАЗА РЕКУРСИИ, ШАГ РЕКУРСИИ И ГЛУБИНА РЕКУРСИИ - САМЫЕ ГЛАВНЫЕ ТЕРМИНЫ
// еще есть такое понятие как максимальная глубина тоесть насколько максемально может рекурсия вернуть сама себя
// она может варьироваться от сложностей действий которые внутри выполняються и возможности железа на котором
// выполняеться весь этот код,
// но что же тогда использовать когда я знаю что оба варианта с рекурсией возможны, это зависит от твоего выбора,
// но есть  несколько ньюансов 

// 1-й из них то что первый способ тоесть перебор при помощи цыкла обычно эфективнее это связано с внутреним
// устройством языка, но если говорить поверхностно  то нужно понимать что здесь #1 когда функция внутри функции
// вызываеться то она должна вообщемто как-то сохранять все те аргументы (n) еще какие-то дополнительные вещи особено
// если будут сложные действия и тд. в первом варианте такого нету

// 2-й ньюанс который нужно учитывать то что с другой стороны рекурсия на самом деле делает функции проще хоть и имеет
// ограничение по глубене тоесть по количеству внутрених вызовов и к тому же здесь #1 функция как-то выглядит намного
// проще  чем через цыкл все делать 

// 3-й ньюанс это то что у каждого свои предпочтения и любимые приемы но большинство програмистов все же склоняються
// к рекурсии и сейчас я покажу почему
// сейчас мы скопируем большой обект и вставим сюда 

let students = { // #1
    js: [{  // #2
        name: 'John', // #5
        progress: 100 // #5
    }, { // #2
        name: 'Ivan', // #5
        progress: 60 // #5
    }],

    html: { // #3
        basic: [{ // #4
            name: 'Peter', // #5
            progress: 20 // #5
        }, {
            name: 'Ann', // #5
            progress: 18 // #5
        }],

        pro: [{ // #4
            name: 'Sam', // #5
            progress: 10 // #5  
        }],

        semi: {
            students: [{
                name: 'Test',
                progress: 100
            }]
        }
    }
};
// здесь у нас есть вложеность в плане что есть один большой объект #1, внутри есть свойства #2, это свойство
// содержит массив с объектами  и объекты внутри содержат какие-то данные, дальше у нас есть отдельное свойство #3
// в котором есть большой объект еще один, внутри есть еще несколько свойств #4, которые содержат внутри себя
// тоже массивы с объектами, на самом деле на первый взгляд кажеться сложно но на самом деле это очень удобно
// хранить данные в таком формате 
// и вот допустим У НАС ЕСТЬ ЗАДАЧА по вычеслению общего процента прогресса со всех курсов которые у меня здесь доутупны
// тоесть почитать вот эти цыфры #5 со свойством porgress для этого мы можем воспользоваться 2-мя методома
// это либо ЦЫКЛ либо РЕКУРСИЯ, напишем оба вареанта и сравним как это будет выглядить, код будет немного
// сложнее чем обычно потому что без усложнение мы не получем програсса, а еще мы познакомимся с парочку
// полезных методов которые мы тут сейчас разберем
// и так наша главная задача сейчас это  посчитать средний прогресс со всех студентов со всех курсов 
// то по факту 1. нам нужно понять сколько вообще студентов, тоесть посчитать их на всех курсах и так же нам
// необходимо общее число в процентах, потом мы берем общее число и делим на количество студентов 

// по этому 1) способ через цыкл, создадим новую функцию назавем её и скажем что в эту функцию у нас приходят какие-то
// данные, дальше нам необходимы 2 главные переменные это (total) - общий прогресс и также (students) - общее количество
// студентов, и в конце скажем что функция вернет нам (total / students) и в конце консоль выведем нашу функцию с students
function getTotalProgressByIterantion(date){
    let total = 0; // #9
    let students = 0 // #9
                      //(       #1        )
    for (let course of Object.values(date)) { 
        if (Array.isArray(course)){ // #3
            students += course.length; // #4

            for (let i = 0; i < course.length; i++){
                total += course[i].progress // #2
            }
        } else {
            for (let subCourse of Object.values(course)) { // #5
                students += subCourse.length; 

                for (let i = 0; i < subCourse.length; i++){
                    total += subCourse[i].progress // #2
                }
            }
        }
    }

    return total / students
}

console.log(getTotalProgressByIterantion(students))

// теперь нам необходимо в середине написать функционал который мы расположем по середине функции, и так, задача такая 
// что  при помощи цыкла мы должны зайти в каждое совйство (#2, #3) внутри и посчитать вот эти #5 все данные
// на этом моменте познакомимся с одним из очень полезных методов у объектов который называеться Object.values()
// делаем мы это для того что бы мы умели работать более удобно работать с теми значениями которые есть в объекте 
// можно заметить что метод values называеться как бы значение соответсвенно здесь (#2, #3) нам не особо интерестно 
// как эти строчки обозначены в самом объекте, нас интересует  то что находиться внутри этих свойств тоесть именно
// значения соответсвенно мы бы хотели получить сразу значения которые есть в этом объекте и работать с ними
// например 
// const object = {
//     a: 'somestring',
//     b: 42,
//     c: false
// };

// console.log(Object.values(object)); // получаеться при помощи метода Object.values() мы в консоль получаем
// массив из нашего указаного в скобках объекта

// теперь возращаемься к нашей функции, в нутри воспользуемься цыклом for ofи также будем использовать наш новый метод
// создали цыкл, переменную которая будет переберать наши свойства и дальше пишем наш метод, по простому мы говорим
// что мы сейчас наш объект (#2, #3) превращаем массив со значениями  превое #2, и второе #3, и у нас формируеться
// массив с двумя вот такими #5 значениями, так как у нас вот здесь #1 этот массив то мы при помощи for of можем
// его перебрать, тоесть каждый отдельный елемент этого массива записать в качестве course,
// теперь в этом course у нас лежит либо массив на данный момент либо объект, и дальше естественно при помощи условия
// мы пишем учловия либо мы работаем с объектом либо с массивом и сначала в условие мы будем проверять 
// если вот то на что мы с вами попали  это массив, таким образом можно определить что какая-то сущность являеться массиво
// 

// и вот для такой манипуляции есть второй метод и называеться он Array.isArray() - возращает true, если объект 
// являеться массивом и false, если он массивом не являеться и вот мы её можем использовать в массиве

// дальше метод мы узнали дальше применяем его в условии, в скобках конечно же пишем course то что мы проверяем на массив
// и дальше внутри пишем действие, что если мы действительно попали на массив то мы с вами должны
// во 1-х посчитать сколько же здесь студентов в этом массиве, а вторая операция это сложить просто вот эти свойства 
// porgress #5, по этому внутри услвоия мы гворим что students += course.length, тоесть нашу переменную
// внутри функции мы прибавляем к длине нашего массива, а так как там в массиве у нас лежат только студены то
// соответсвенно у нас получеться двоечка и она поместиться в переменную students указаную в нашей функции
// и так студентов мы записали но теперь также нужно записать total тоесть заместь нуля поставить циферки
// как это можно зделать, в массиве у нас объекты тоесть нам нужно опять таки перебрать этот массив и вытащить каждый 
// свойство progress его значение и с каждого объекта, в условияъ мы запустим цыкл, создаем переменную i
// говорим что цыкл будет длиться до тех пор пока не закончить длина нашего course и прибавляем i на 1 (i++),
// дальше мы говорим что total у нас будет увеличиваться  total += course, теперь мы с вами обращаемся course тоесть к
// массиву,  и так как внутри у нас получаеться объекты они по счету идут #2, то мы можем здесь #2 обратиться по индексу
// course i, и так как это объект через точку мы можем прост ообратиться через точку к свойству progress
// теперь у нас есть первая гтовая ветка когда мы с вами попадаем в масисв

// теперь вторая часть когда мы с вами оппадаем не на массив как здесь (#2), а на объект как здесь(#3)
// для этого в пишем уже else тоетсь если не массив, и попав на это объект нам нужно опять посмотреть что в нутри
// этого объекта и это не чем не отличаеться от нашего большого объекта который мы разберали, мы опять при помощи
// метода Object.values() можем посмотреть что в нем находиться и опять задавать все те же операции, да, почему, потому
// что нам опять таки вот эти свойства #4 нас не интересуют, нас интересует именно значения внутри их,
// проделываем тот же цыкл что и с массивами for (let course of Object.values(date)), но теперь заместь
// course пропишим subCourse, только теперь внутри Object.values(date)), у нас будет не date а course
// Object.values(course)), потому что мы уже раматриваем не весь  большой объект 'students' а именно то что мы получили
// вот здесь (#2, #4), дальше мы раскрываем этот цыкл, если мы говори про тикущий объект то что мы можем здесь полуить
// это (#4 - basic и pro) и здесь у нас только массивы тоесть пока нам даже не нужно проверять что здесь  будет массив
// так что мы здесь просто увеличиваем количество студентов students += course.length; точно такая же операция
// только здесь у нас будет не course а subCourse, и к тому же нам надо тоже увеличить total по этому тоже
// скопируем то что писали, только опять надо не забыть поменять course на subCourse

// все, и так пример не самый простой но он очень показательный  и если обяснить все эти операции коротко
// то здесь довольно все просто мы получаем значение #1, проверяем если ли это массив #3 то выполняем
// эти операции #4, если это объект #5 то мы находим все что внутри  и выполняем все тежи операции #3,
// НО ОПЯТЬ ТАКИ ДАВАЙТЕ ВЕРНЕМСЯ В РЕАЛЬНОСТЬ, мы знаем что программы и код постоянно могут меняться и это нормально
// а если внутри html у нас появиться еще один подкурс вот здесь #3 при чем здесь имею виду не просто массив
// как это было с basic и pro(#4), а какой-то some: - который у нас будет опять объектом внутри которого еще одно
// свойство и внутри еще один массив, такой код у нас уже не пройдет потому что мы здесь #3, сразу орентировались
// на готовую структуру там мы думали что здесь будет объект в котором будут свойства содержащие только массивы
// вот раз массив и два массив(#4), а вот в наши планы не входило что вот здесь где появиться some, будет еще 
// какой-то объект и в таком случае нам прийдеться усложнять нашу функцию, которую мы с вами написали
// мы должны будем опять на этом уровне #5 писать проверку на то что нам сюда может прийти еще массив и здесь будут 
// очень такие вложенные данные, вот все тоже самое будет повторяться и разширяться, представь какой будет огромный 
// бардак в этой функции и сколько раз мы будем повторять один и тот же код и вот что бы таких моментов не возникало
// и можно использовать РЕКУРСИЮ которая какрас будет все далать все за вас, помним что мы говорили, что как бы
// РЕКУРСИЯ она упращает функцию  потому что мы все однотипные действия заключаем в функцию и она уже в нутри себя
// её просто каждый раз вызывает 
// так что теперь давайте напишем 2-й вариант 

// создадим функцию которая называеться getTotalProgressByRecursion и скажем что эта функция тоже будет получать 
(date)

function getTotalProgressByRecursion(date) {
    if (Array.isArray(date)){  // #1
        let total = 0;  // #2

        for (let i = 0; i < date.length; i++){ // #3
            total += date[i].progress 
        }

        return [total, date.length]// #4
    } else { // #5
        let total = [0, 0];
        
        for (let subDate of Object.values(date)) {
            const subDateArr = getTotalProgressByIterantion(subDate); // #6
            total[0] += subDateArr[0]; // #7
            total[1] += subDateArr[1]; // #7
        }


        return total
    }
}

const result = getTotalProgressByRecursion(students)

console.log(result[0]/result[1])

// для начала определимся с базовыми понятиями которые мы с вами уже разбирали и так, что у нас будет базой Рекурсии
// тоесть тот случай который заканчивает функцию, в этих данных #1 нашего объекта, я считаю что это будет
// у нас какой-то массив, почему массив, потомучто как только мы натыкаемся на него то у нас уже все понятно 
// внутри будут объекты только со студентами, дальше мы можем просто скопировать те же действие что в первом способе
// именно с условием на массив, но нам нужно немного поменять, заемться course #1 мы поставим наш аргумент(date), 
// тоесть говорим что наш (date) может быть массивом, а такое может быть, потому что с первым способом
// мы как бы знали что наш (date) объект, но мы же можем не знать какие данные приходят или какой это тип данных и тд.
// зачем усложнять Функцию и писать много условий, по этому мы ставим наш объект на проверку, а дальше нам просто
// нужно посчитать эти все данные тоесть сколько студентов и сложить их общий прогресс, но попрошу заметить, что когда
// мы работаем с Рекурсией у нас нет таковых промежуточных переменных, тоесть например  как здесь
function pow(x, n) { // здесь у нас есть промежуточная переменная
    let result = 1; // переменная

    for (let i = 0; i < n; i++){
        result *= x; // и уже на базей этой переменной при помощи цыкла мы все расчитовалось
    }
    
    return result;
}

// Когда мы использовали рекурсию то здесь некаких промежуточных переменных нет, вот пример, но почему потому что 
function pow(x, n) { // они расчитываються на уровне функции (#1) и как бы возращаються сюда и получаем итоговый результат
    if (n === 1){ 
        return x 
    } else {
        return x * pow(x, n -1) // #1  
    }
}
// тоже самое в первом варианте у нас были переменные и на базе их мы высчитывали #9,

// Когда мы с вами используем Рекурсию то здесь у нас таких вещей не будет, то нам надо подумать что нам делать с этими
// переменными, давайте здесь #2, внутри условия все же создаим  переменную total она бдует ровна 0
// почему, потому что её все таки прийдеться вычеслить так как внутри у нас есть студенты, а вот общее воличестов
// студентов мы можем получить как (date.length), потому что у нас сколько елементов в массиве столько и студентов
// но пока что давайте посчитаем total, course меняем на date и все, получаеться внутри этого условия мы с вами посчитаем
// сколько будет porgress, и также у нас уже есть здесь #3 общее количество студентов, теперь помним что в первом случае
// примером с Рекурсией мы что то возращали, по этому нам всегда нужно возращать какоето значение 
// по этому здесь #4 мы с вами возращаем не одно какое то число, значение или логический тип, а просто массив,
// помним что при помощи return можно вернуть все что угодно, в том числе и массив с данными  где мы с вами 
// содержим все те же переменные которые были в первом варианте(total и students), и так, базу мы написали тоесть
// когда сразу мы натыкаемся на массив, теперь напишем вторую часть, это вообщемто будет уже сама Рекурсия когда мы 
// с вами попадаем вот как прямо сейчас на объект и внутри мы его будем перебирать, возращаемся в Функцию
// и так как в обычной функции(в первом примере) у нас было обявлено 2 переменных, то здесь мы можем зделать похожую
// вещь которая будет как бы, промежуточным результатом, напишем total [0, 0] - это тоже допустимо, это у нас
// массив с числами, теперь смотрите, так как здесь #5 мы точно получим объект, потому что мы уже как бы в случае
// с массивом мы описали полностью, то здесь мы можем написать for(of) перебор, мы говорим что будем обращаться
// к subDate так как это уже точно у нас объект мы можем взять его значение Object.values(date) с date, раскрываем его
// и вот теперь самый важный момент все рекурсии #6, потому что сейчас так как у нас есть какието вложеные данные
// то мы с вами должны саму же функцию запустить на этих данных, тоесть мы вот здесь в объекте students #3
// попали на внутриние свойства и для каждого этого либо объекта либо массива мы заново запускаем эту функцию 
// которая будет обрабатывать её, соответсвено мы как бы распростроняем действие этой функции на внутриние структуры
// и так как мы знаем что нам здесь #4 вернеться массив, потом мы четко знаем что здесь #6 будет массив с данными
// и вот здесь м ызапускаем нашу функцию внутри себя с уже аргументом subDate и она будет запускать внутри себя
// случай до тех пор пока не дойдет до базы #4, тоесть на конечный массив, но не стоит забывать что когда мы 
// запускаем Рекурсию то она далеко не сразу может наткнуться на ммасив соответсвено вот здесь #6 когда мы получили
// массив данных, нас интересует конечная переменная total, то мы к total будем добовлять к subDateArr теость первый
// елемент к первому, а когда у нас сработал блок кода else мы проста сохраним наше значение total

// и так теперь еще раз пробежимся по нашей функции с рекурсией что бы все было понятно
function getTotalProgressByRecursion(date) { // #1
    if (Array.isArray(date)){  // #2
        let total = 0;  // # 3

        for (let i = 0; i < date.length; i++){ // #4
            total += date[i].progress // #5
        }

        return [total, date.length]// #6
    } else { // #7
        let total = [0, 0]; // #8
        
        for (let subDate of Object.values(date)) { // #9
            const subDateArr = getTotalProgressByIterantion(subDate); // #10
            total[0] += subDateArr[0]; // 11
            total[1] += subDateArr[1]; // 12
        }


        return total // #13
    }
}
// мы с вами запускаем функцию рекурсии #1 в ней попадает какието данные, это может сразу массив, если это так
// то мы с вами вот эту часть кода if(от #2 до #6), здесь #2 мы сразу проверяем что это массив, мы добовляем
// переменную total #3 и складываем все наши progress #5 каждого из студентов при помощи нашего цыкла #4 в одну
// и ту переменную #3, так как мы с вами должны расчитывать сразу два значения не тоько общий прогресс всех этих 
// студентов но и также общее их количество и тут #6 мы с вами взяли и вернули сразу два значения, мы можем зделать
// это при помощи одного массива, если же вдруг этот объект который нам приходит это не массив, то в таком случае
// мы попадаем в блок кода else #7,  здесь мы сразу формируем этот массив с нулями что бы туда записать какието значения
// и вернуть их в работу, дальше так как у нас это объект то мы его с вами должны перебрать, каждое отдельное свойство
// #9, само название свойства нас не интересует, по этому мы хотим получить лишь их значения тоесть Object.values(date)#9
// какрас date туда и приходит, соответсвено мы с вами обращаемься к каждому из этих значений свойств в качестве
// subDateArr #9, и дальше так как у нас это объект он может содержать еще какието внутриности например то что 
// в объекте student выше, свойство basic содержит у нас массив и pro тоже содержит массив, а semi тут уже  объект
// соответсвено мы не можем прямо сказать сейчас что там будет находиться по этому все что мы делаем это заново запускаем
// getTotalProgressByRecursion() нашу функцию только уже с subDateArr тоесть с вот этими вложеными данными
// и дальше уже вот эта внутреняя функция будет решать что делать если в итоге она сразу же наткнулась на масив
// она просто высчитывает данные и возращает их вот сюда #10 соответсвено они попадают в массив и потом дальше
// ужеидут в работу, если эта функция опять наткнулась на объект, тоетськак это было вот здесь когда мы наткнулись на
// semi, то она опять попадает в блок кода else #7 она опять получает именно значения этого объекта и опять она
// уже запускает Рекурсию тоесть у нас идет как бы вложность этих функцый и каждая из этих функций  в итоге у нас будет
// возращять массив данных, ведь если это у нас массив #6, тоу нас возращаеться такой #6, если это у нас объект
// то мы в итоги всеровно вернем #13 total который являеться массивом с данными #8, в итоги самая первая главная
// функция которая все сумирует она либо вернет нам первый базовый случай #6, если вдруг наш общий объект который
// мы передаем он будет массивом либо вот здесь #10 постепенно будет сумироватьс эти данные в переменную total #13
// они опять возращаються опять попадают в определеный массив и так по кругу 









