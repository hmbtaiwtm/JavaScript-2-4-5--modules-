// let number = 5;

// function logNumber() {
//     let number = 4
//     console.log(number)
// }

// number = 6;

// logNumber()

// в Js у каждой выполняемой  функции, блока кода и скрипта есть связаный с ними внутрений тоесть скрытый от нас объект
// который называеться лексическое окружение или lexical environment - внутрений технический скрытый объект
// мы его не можем просто так увидеть причем это лексическое окружение делиться на 2 части на внутриние и внешнее
// функция когда зупститься она сначала будет искать внутри себя  значение number а когда она не находит то она обращаеться
// уже к глобальному значению number
// и так 1) 

// ВНУТРИНИЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ
// это объект в котором как свойства хроняться все локальныые переменные этой функции

// 2) ВНЕШНЕЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ
//  то что соответсвует коду снаруже этой функции 

// ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ ЭТО ВСЕ ТАКИ ТЕХНИЧЕСКИЙ ОБЪЕКТ    
// и любая переменная которая находиться внутри функции или снаруже на самом деле это просто свойство со значение
// И ТАК ЛЮБАЯ ПЕРЕМЕННАЯ ЭТО СВОЙСТВО ОБЪЕКТА ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ
// В JS ОБЪЕКТ ЭТО САМАЯ ГЛАВНАЯ СУЩНОСТЬ 
// ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ ЭТО ТЕХНИЧЕСКИЙ ОБЪЕКТ И НАПРЯМУЮ МЫ С НИМ ВЗАЕМОДЕЙСТВОВАТЬ НЕ МОЖЕМ НИ КАК ПО ФАКТУ
// ЕГО КОНТРЛИРУЕТ ИНТРОПРЕТАТОР(БРАЗУЕР)

// РАЗ МЫ ЗНАЕМ ЧТО ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ СУЩЕСТВУЕТ У ЛЮБОГО БЛОКА КОДА ОГРАНИЧЕНОГО ФИГУРНЫМИ СКОБКАМИ ТО
// РАСМОТРИМ ВАРИАНТЫ ПО ПОРЯДКУ
// САМОЕ ВАЖНОЕ И СЛОЖНОЕ ЧТО НУЖНО ПОНИМАТЬ ЭТО ЗАМЫКАНИЕ ФУНКЦИЙ

// let number = 5;

// function logNumber() {   //- 1
//     let number = 4; // - 3
//     console.log(number)//- 4
// }

// number = 6; // - 5

// logNumber() // - 2

// ВОТ У НАС ЕСТЬ ФУНКЦИЯ ПРОЙДЕМСЯ ПО НЕЙ КАК ИМЕННО ОНА РАБОТАЕТ В КОДЕ И КАКИЕ ЭТАПЫ ПРОХОДИТ
// СНАЧАЛА ОНА БЫЛА СОЗДАНА (1) И В КАКОЙТО МОМЕНТ ВЫЗЫВАЕТЬСЯ В КОДЕ (2) ДАЛЬШЕ ФУНКЦИЯ СТАРТУЕТ С ТОГО ЧТО ОНА
// СОЗДАЕТ ВНУТРИ СЕБЯ ТЕ ПЕРЕМЕННЫЕ КОТОРЫЕ В НЕЙ ВООБЩЕМТО И БЫЛИ СОЗДАНЫ (3), ИЗНАЧАЛЬНО ПЕРЕМЕННАЯ number 
// БЫЛА undefined ПОСЛЕ ЭТОГО ИДЕТ ВЫЗОВ И СОЗДАНИЕ ВНУТРИНЕГО И ВНЕШНЕГО ТОЕСТЬ ГЛОБАЛЬНОГО ЛЕКСИЧНОГО ОКРУЖЕНИЯ
// ТОЕСТЬ СОЗДАЮТЬСЯ ТЕ ПЕРЕМЕННЫЕ, ДАЛЬШЕ ИДЕТ ПРИСВОЕНИЕ (3) КАКИЕТО ЗНАЧЕНИЕ, ДО ТЕХ ПОР ПОКА НЕ БУДЕТ ВЫЗВАНАЯ КАКАЯ-ТО
// КОМАНДА КОТОРАЯ РАБОТАЕТ С ЧЕМ-ТО, ДОПУСТИМ КАК У НАС КОНСОЛЬ ЛОГ(4)
// КОГДА МЫ ДОХОДИМ ДО РОБОТЫ ДОПУСТИМ С number (4) ТО ЭТА ФУНКЦИЯ ИМЕЕТ В СЕБЕ ЛОКАЛЬНЫЙ ОБЪЕКТ ЛИКСИЧЕСКОГО ОКРУЖЕНИЯ
// И ГЛОБАЛЬНЫЙ ОБЪЕКТ  СООТВЕТСВЕННО У ЛОКАЛЬНОГО ОБЪЕКТА ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ ЕСТЬ СЫЛЛКА НА ГЛОБАЛЬНЫЙ И СДЕЛАНО 
// ЭТО ДЛЯ ТОГО ЧТО ЕСЛИ ВДРУГ У НАС ФУНКЦИЯ НЕ НАЙДЕТ NUMBER (4) У СЕБЯ В ЛОКАЛЬНОМ ХРАНИЛЕЩЕ ТО ОНА БУДЕТ ОБРАЩАТСЯ
// К ГЛОБАЛЬНОМУ ЛЕКСИЧЕСКОМУ ОКРУЖЕНИЕ И В ТАКОМ СЛУЧАЕ ОНА БУДЕТ ИСПОЛЬЗОВАТЬ ЭТО ЛЕКСИЧЕСКОЕ ЗНАЧЕНИЕ (5)

// ФУНКЦИЯ ПОЛУЧАЕТ ВСЕГДА ТЕКУЩЕЕ ЗНАЧЕНИЕ В НЕШНИХ ПЕРЕМЕННЫХ ТОЕСТЬ ИХ ПОСЛЕДНЕЕ ЗНАЧЕНИЕ (5) А ВОТ СТАРЫЕ
// ЗНАЧЕНИЕ ПЕРЕМЕННЫХ ОНИ НЕГДЕ НЕ СОХРАНЯЮТЬСЯ

// КАЖДЫЙ ВЫЗОВ ФУНКЦИИ ЭТО СОЗДАНИЕ НОВОГО ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ СО СВОИМ КАКИМ ТО СПЕЦЕФИЧНЫМ ДЛЯ ЭТОГО ВЫЗОВА
// ЛОКАЛЬНЫМИ ПЕРЕМЕННЫМИ ЛОКАЛЬНЫМИ 
// ПРИМЕР 

// let number = 5;

// function logNumber() {  
//     let number = 4; 
//     console.log(number) 
// }

// number = 6; 

// logNumber() 

// number = 8; // ВОТ НОВОЕ ЗНАЧЕНИЕ

// logNumber()   // ВОТ НАГЛЯДНЫЙ ПРИМЕР

// // СНОВА ВЫЗВАЛИ ФУНКЦИЮ И ОНА СОЗДАЛА НОВОЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ И В КОДЕ ВЫВЕДЕТЬСЯ 8 


// function createCounter() { // - 1
//     let counter = 0; // - 3

//     const myFunction = function(){ // - 4
//         counter = counter + 1; // - 5
//         return counter; // - 10
//     }

//     return myFunction // - 6
// }

// const increment = createCounter() // - 2
// const c1 = increment(); // - 7
// const c2 = increment(); // - 8
// const c3 = increment(); // - 9

// СНАЧАЛА МЫ СОЗДАЕМ ПЕРЕМЕННУЮ (1) И ПРИСВАИВАЕМ ЕЙ ВЫПОЛНЕНИЕ ФУНКЦИИ ДАЛЬШЕ  В (2) МЫ СОЗДАЕМ НОВУЮ ПЕРЕМЕННУЮ
// КОТОРАЯ ИЗНАЧАЛЬНО undefined ОНА ПОМЕЩАЕТЬСЯ КАК БЫ В ГЛОБАЛЬНУЮ ОБЛАСТЬ ВЫПОЛНЕНИЯ И ДАЛЬШЕ ИДЕТ ВЫЗОВ ФУНКЦИИ 
// createCounter (2)  И ДАЛЬШЕ ВОЗРАЩАЕМСЯ В ЭТИ СТРОКИ (3) В ПЕРВУЮ ОЧЕРЕДЬ У НАС БУДЕТ СОЗДАНА ПЕРЕМЕННАЯ СО ЗНАЧЕНИЕМ
// undefined, ПОСЛЕ ЭТОГО У НАС БУДЕТ В ЭТОЙ ФУНКЦИИ В ЭТОМ ВЫХОВЕ ФУНКЦИИ БУДЕТ СОЗДАВАТЬСЯ НОВАЯ ЛОКАЛЬНАЯ И
// ГЛОБАЛЬНАЯ ОБЛАТСЬ ВЫПОЛНЕНИЯ (ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ), В ЭТОМ ЛЕКСИЧЕСКОМ ОКРУЖЕНИЕ У НАС ЕСТЬ ЛОКАЛЬНАЯ ПЕРЕМЕННАЯ
// counter (3) СО ЗНАЧЕНИЕ 0 В ГЛОБАЛЬНОМ ПОКА ЧТО  ВООБЩЕМ ТО У НАС НИЧЕГО НЕ БУДЕТ НАВЕРНОЕ БУДЕТ ТОЛЬКО СЫЛЛКА НА
// increment (2) И ТО ОНА НАМ НЕ ОСОБО ВАЖНА ПОТОМУ ЧТО ТАМ ПРОСТО undefined
// ДАЛЬШЕ В ЭТИХ СТРОКАХ (4) СОЗДАЕТЬСЯ НОВАЯ ФУНКЦИЯ, ИЗНАЧАЛЬНО СОЗДАЕТЬСЯ ПЕРЕМЕННАЯ myFunction КОТОРАЯ СОДЕРЖИТ
// ЗНАЧЕНИЕ undefined А ПОСЛЕ ЭТОГО В НЕЁ УЖЕ ПОМЕЩАЕТЬСЯ  ЗНАЧЕНИЕ ФУНКЦИИ, САМИ ВНУТРЕНОСТИ ЭТОЙ ФУНКЦИИ
// ЗАПИСУЮТЬСЯ СДЕСЬ (5) И ВОТ ЗДЕСЬ МЫ СОЗДАЕМ ЗАМЫКАНИЯ КОТОРОЕ ЯВЛЯЕТЬСЯ ЧАСТЬЮ ВОТ ЭТОЙ ФУНКЦИИ (4) ЭТО ЗНАЧИТ ЧТО
// КОГДА ФУНКЦИЯ ВЫЗВЕТЬСЯ ОНА БУДЕТ ХРАНИТЬ В СЕБЕ СЫЛЛКУ counter (3) ТОЕСТЬ В ЛЕКСИЧЕСКОМ ОКРУЖЕНИЕ БУДЕТ
// СОХРАНЕНА ССЫЛКА НА ПЕРЕМЕННУЮ, СЛЕДУЩАЯ СТОЧКА ВОТ ЗДЕСЬ (6) МЫ ВОЗРАЩАЕМ СОДЕРЖИМОЕ ПЕРЕМЕННОЙ myFunction
// ЛОКАЛЬНАЯ ОБЛАСТЬ ВЫПОЛНЕНИЯ ТОЕСТЬ ВНУТРИНИЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ У ЭТОЙ ФУНКЦИИ У НАС БУДЕТ УНИЧТОЖЕННО
// ПОТОМУЧТО БОЛЬШЕ ОНО НАМ НЕ НУЖНО НО НАРУЖУ МЫ СВАМИ ВОЗРАЩАЕМ ОПИСАНИЕ ЭТОЙ ФУНКЦИИ ТОЕСТЬ ТО ЧТО ПРОИСХОДИТ
// ВНУТРИ ЕЕ ЗАМЫКАНИЕ ТО НА ЧТО ОНА БУДЕТ ССЫЛАТЬСЯ, ТОЕСТЬ КОГДА МЫ СОЗДАВАЛИ ВОТ ЭТУ ФУНКЦИЮ (4) ОНА ВИДЕЛА
// ВНЕШНЕЙ  counter (3) И КОГДА МЫ ФУНКЦИЮ ВОЗРАЩАЕМ КУДАТО НАРУЖУ (6) ОНА ВСЕРОВНО ПРОДОЛЖАЕТ ВООБЩЕМТО ХРАНИТЬ
// СЫЛЛОЧКУ  НА ВОТ ЭТОТ counter (3) ХОТЯ ВНУТРИНИЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ ЭТОЙ ФУНКЦИИ ИСЧЕЗЛО ТОЕСТЬ ОНО БЫЛО УДАЛЕННО
// И ВООБЩЕМТО ВСЕ ЭТО ТЕПЕРЬ У НАС БУДЕТ СОДЕРЖАТЬСЯ В ПЕРЕМЕННОЙ increment (2) В ТОМ ЧИСЛЕ И ЗАМЫКАНИЕ ЭТОЙ
// ФУНКЦИИ, В СЛЕДУЩЕЙ СТРОКЕ (7) МЫ СНАЧАЛА СОЗДАЕМ ПЕРЕМЕННУЮ c1 СО ЗНАЧЕНИЕМ undefined А ДАЛЬШЕ ВЫЗЫВАЕМ
// increment (7) ДЛЯ ТОГО ЧТО БЫ ЧТО ТО ТУДА c1 ЗАПИСАТЬ, ТЕПЕРЬ ВЫЗЫВАЕМ НОВУЮ ФУНКЦИЮ increment (7) И СООТВЕТСВЕНО
// БУДЕМ ВЫЗВАТЬ ЕЁ НОВОЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ, ПОМНИМ ЧТО КАЖДЫЙ РАЗ КОГДА ВЫЗЫВАЕМ ФУНКЦИЮ У НЕЕ СОЗДАЕТСЬЯ НОВОЕ
// ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ, ЭТО ЗНАЧИТ ЧТО МЫ ТЕПЕРЬ ПЕРЕМЕЩАЕМЬСЯ СЮДА (5) И НАША ФУНКЦИЯ increment (7) СНАЧАЛА
// СМОТРИТ НА counter СУЩЕСТВУЕТ ЛИ ТАКАЯ ПЕРЕМЕННАЯ ВНУТРИ ЭТОЙ ФУНКЦИИ  myFunction (4), НЕТ НО КОГДА МЫ СОЗДАВАЛИ
// ОПИСАНИЕ ЭТОЙ ФУНКЦИИ  myFunction (4) ТОЕСТЬ ВСЕ ТО ЧТО ОНА СОДЕРЖИТ МЫ ТАКЖЕ СОХРАНИЛ ССЫЛКУ НА ВОТ ЭТОТ counter (3)
// increment ЕЕ ДОСИХ ПОР ХРАНИТ  ТОЕСТЬ ЗДЕСЬ counter = counter + 1 (5) МЫ ПОДСТАВЛЯЕМ 0 + 1 И СООТВЕТСВЕННО
// ЗДЕСЬ  let counter = 0; (3) У НАС ТОЖЕ БУДЕТ ЕДЕНИЧКА 1 И ПОСЛЕ ЭТОГО МЫ ВОЗРАЩАЕМ ЗНАЧЕНИЕ 1  return counter; (10)
// И В ПЕРЕМЕННУЮ c1 (2) ЗАПИСЫВАЕТЬСЯ ЕДЕНИЦА 1, ДАЛЬШЕ У НАС ТОЖЕ САМОЕ СОЗДАЕМ ПЕРЕМЕННУЮ c2 (8) СО ЗНАЧЕНИЕМ
// undefined И У НАС ИДЕТ ОПЯТЬ ЗАПУСК ФУНКЦИИ increment (8), ПЕРЕМЕЩАЕМСЯ ВОТ СЮДА counter = counter + 1 (5)
// ЗДЕСЬ  counter ПОМНИТ ВСЕ ТУ ЖЕ ССЫЛКУ НА ТОТ ЖЕ let counter = 0; (3) ВОТ ЭТУ ПЕРЕМЕННУЮ  КОТОРАЯ ХРАНИТЬСЯ В ЕГО 
// ЗАМЫКАНИЕ И СЕЙЧАС ВОТ ЭТА ПЕРЕМЕННАЯ let counter = 0; (3) СОДЕРЖИТ УЖЕ 1 ТАК ЧТО ЗДЕСЬ МЫ counter = counter + 1 (5)
// ДОБОВЛЯЕМ 2 И СЮДА УЖЕ ПОМЕЩАЕТЬСЯ ДВОЙКА  let counter = 0; (3) И ДВОЙКА ВОЗРАЗАЕТЬСЯ УЖЕ ВОТ СЮДА 
// const c2 = increment(); (8) ТОЖЕ САМОЕ БУДЕТ И С ТРОЙКОЙ const c3 = increment(); (9)

//ВАЖНАЯ ТЕХНИЧЕСКАЯ ДЕТАЛЬ - КАКИМ ОБРАЗОМ ФУНКЦИИЯ ВООБЩЕ ЗНАЕТ ЧТО ЕЙ БРАТЬ И ПОМЕЩЯТЬ В ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ
// ВЕДЬ ДОЛЖЕН БЫТЬ КАКОЙТО МЕХАНИЗМ И ОН ЕСТЬ, ОН РЕАЛЬЗУЕТЬСЯ ЧЕРЕЗ СКРЫТОЕ СВОЙСТВО ENVIRONMENT КОТОРОЕ ССЫЛАЕТЬСЯ
// НА ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ МЕСТО ГДЕ ЭТА ФУНКЦИЯ myFunction  БЫЛА СОЗДАНА, ПО ПРОСТОМУ ЭТО КОГДА ФУНКЦИЯ
// БЫЛА ЗДЕСЬ СОЗДАНА (4) ТО ОНА ПОЛУЧИЛА ССЫЛКУ НА ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ ТОГО  МЕСТА ГДЕ ОНА БЫЛА СОЗДАНА ТОЕСТЬ
// НА ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ  ФУНКЦИИ createCounter, ВОТ ИМЕННО БЛОГОДОРЯ ЭТОМУ СВОЙСТВУ ENVIRONMENT ФУНКЦИЯ
// И ЗНАЕТ ЧТО ПОЛОЖИТЬ К СЕБЕ В ЗАМЫКАНИЕ ТОЕСТЬ В СВОЕ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ

// ЗАМЫКАНИЕ ЭТО ФУНКЦИЯ КОТОРАЯ ЗАПОМИНАЕТ СВОИ ВНЕШНИЕ ПЕРЕМЕННЫЕ И МОЖЕТ ПОЛУЧИТЬ К НИМ ДОСТУП А ЧТО БЫ ПОНЯТЬ 
// ПОЧЕМУ ТАК ПРОИСХОДИТ СТОИТ ОСВИТЬ ТЕРМИНЫ ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ И СВОЙСТВО ENVIRONMENT

// ЛЕКСИЧЕСКОЕ ЗНАЧЕНИЕ ЕСТЬ НЕ ТОЛЬКО У ФУНКЦИЙ ОН ПРИСУТСВУЕТ И У ЛЮБОГО БЛОКА КОДА 
// ВОТ ПРИМЕР

{
   let msg = 'hello'
}

console.log(msg)  // КОД ВЫДАСТ ОШИБКУ ЧТО msg is not defined,  ЭТА ПЕРЕМЕННАЯ ДОСТУПНА ТОЛЬКО ВНУТРИ ЛЕКСИЧЕСКОГО
// ОКРУЖЕНИЯ СКОБОК И НЕ ДОСТУПНО СНАРУЖИ, ПОТОМУ ЧТО ОНА СУЩЕСТВУЕТ ТОЛЬКО ВНУТРИ ЭТОГО БЛОКА, ТОЖЕ САМОЕ
// И В ЦЫКЛАХ УСЛОВИЯХ И ТОМУ ПОДОБНОЕ 
// ВОТ ЕЩЕ ПРИМЕР И ВОПРОС КОТОРЫЫЙ ЗАДАЮТ НА СОБЕСЕДОВАНИЕ

for (let i = 0; i < 9; i ++){
    for(let j = 0; j < 9; j++){ // - 1
        let num = 3;
    }

    
}



// опять таки код вдаст ту же ошибку is not defined потому что num будет существовать только унтри фигурнх скобок
// тоетсь внутри ЛЕКСИЧЕСКОГО ОКРУЖЕНИЯ этого цыкла причем каждой его итерации и внутри каждой итерации вот 
// этого цыкла (1) будет создаваться свой num и конечно же снаржи м с вами его получить не можем
// так что  ЛЕКСИЧЕСКОЕ ОКРУЖЕНИЕ  может существовать внутри любых скобок 